/*
thread1: LOOP till end of game
thread2: LOOP till end of gameo
*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ipc.h>
#include <unistd.h>
#include <sys/types.h>
#include <string.h>
#include <pthread.h>

#define FIRST 1 // first thread to be executed
#define SECOND 2
#define LRAND 0
#define BRAND 100
#define NONEW 0
#define NEW 1

#define VSMALLER 0
#define VGREATER 2
#define VEQUAL 1

#define SMALLER "smaller than"
#define GREATER "greater than"
#define EQUAL "equal to"

// mutex to be used to synchronize both threads
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
// conditional variables to manage threads alternance
pthread_cond_t cond_var1 = PTHREAD_COND_INITIALIZER;
pthread_cond_t cond_var2 = PTHREAD_COND_INITIALIZER;

int current_thread = SECOND; // this will be the first thread to be executed

void err_sys(const char* text)
{
    perror(text);
    exit(1);
}

struct shmseg {
	int client;
	int iteration;
	int comparison;
};

struct shmseg shm;

int compare(int n1,int n2);

// function to handle thread 1 (server)
void *handle_thread1(void *vargp)
{
   int Zs; //random number generated
   int Zc;
   int i, j;
   char message[3][20];
   int iteration;
   int result;

   strcpy(message[0], SMALLER);
   strcpy(message[1], EQUAL);
   strcpy(message[2], GREATER);
   srand(time(NULL)+getpid());

   //generate random number
    Zs = (rand() % (BRAND - LRAND +1)) + LRAND;
    iteration = shm.iteration;


   while (1)
   {
	// check mutex is ready
	pthread_mutex_lock(&mutex);
	// critical zone
	if (current_thread == SECOND)
	{
	// unlock mutex and block thread1
	  pthread_cond_wait(&cond_var1, &mutex);
	}

	//time for thread1
	// next thread after mutex unlock will be thread2
	current_thread = SECOND;

       //just in the critical zone
        // client has generated random number
       Zc = shm.client;
       // compare values
      result = compare(Zc,Zs);
      shm.comparison = result;
      iteration += 1;
      shm.iteration = iteration;
      printf("Iteration %d, client number %d, result is %s\n", shm.iteration,shm.client,message[result]);

        //exiting critical zone
	//end crtical zone
        //awake thread2
        pthread_cond_signal(&cond_var2);
	//release mutex
	pthread_mutex_unlock(&mutex);
        if ( result == VEQUAL) break;
   }
    printf("T1: End of thread 1\n");
    printf("T1: The number of iterations has been %d\n", shm.iteration);
    printf("T1: The server value has been %d\n", shm.client);
}

// function to handle thread 2 (second player)
void *handle_thread2(void *vargp)
{
   int Zs; //random number generated
   int i, j;
   int result;
    int Z1; //low range interval
    int Z2; //high range interval
    int Zc; //number generated by client (middle of interval)
    char message[3][20];
    int last = 0; // to avoid generate always the same number

    strcpy(message[0], SMALLER);
    strcpy(message[1], EQUAL);
    strcpy(message[2], GREATER);

    Z1 = LRAND;
    Z2 = BRAND;
   srand(time(NULL)+getpid());

   while (1)
   {
        // check mutex is ready
        pthread_mutex_lock(&mutex);
        // critical zone
        if (current_thread == FIRST)
        {
        // unlock mutex and block thread1
          pthread_cond_wait(&cond_var2, &mutex);
        }

        //time for thread2
        // next thread after mutex unlock will be thread1
        current_thread = FIRST;
       //just in the critical zone
      //generate random number
        Zc = Z1+ (Z2-Z1) / 2;
        if (Zc == last) Zc++;
        last=Zc;
        shm.client = Zc;
        //exiting critical zone
        //awake thread1
        pthread_cond_signal(&cond_var1);
        //release mutex
        pthread_mutex_unlock(&mutex);
	// wait for result
        // check mutex is ready
        pthread_mutex_lock(&mutex);
        // critical zone
        if (current_thread == FIRST)
        {
        // unlock mutex and block thread1
          pthread_cond_wait(&cond_var2, &mutex);
        }
        //time for thread2
        // next thread after mutex unlock will be thread2
        current_thread = SECOND;
       //just in the critical zone
       //check result
        if (shm.comparison == VEQUAL) break;
        if (shm.comparison == VSMALLER) Z1=Zc;
        if (shm.comparison == VGREATER) Z2=Zc;
	//awake thread2
	pthread_cond_signal(&cond_var2);
        //release mutex
        pthread_mutex_unlock(&mutex);
   }
    printf("T2: End of thread 2\n");
    printf("T2: The numbwe of iterations has been %d\n", shm.iteration);
    printf("T2: The server number has been %d\n", shm.client);
}

int main(int argc, char *argv[])
{
//to manage the two threads needed on the program
    pthread_t handleThread_id1;
    pthread_t handleThread_id2;

    int     sem_value;
    int     result;
    int shmid;
    struct shmseg *shmp;
    int i, j;

//set values for memory segment
    shm.client=0;
    shm.iteration=0;
    shm.comparison = 0;

// create noth threads
    pthread_create(&handleThread_id1, NULL, handle_thread1, NULL);
    pthread_create(&handleThread_id2, NULL, handle_thread2, NULL);

// wait end of both threads
    result = pthread_join(handleThread_id1, NULL);
    if (result > 0) err_sys("Error joining thread 1 at end of program");
    result = pthread_join(handleThread_id2, NULL);
    if (result > 0) err_sys("Error joining thread 2 at end of program");

    printf("End of Game\n");
    printf("The number of iterations has been %d\n", shm.iteration);
    printf("The server value is %d\n", shm.client);

}


int compare(int n1, int n2)
{
        if (n1 < n2) return(0);
        if (n1 == n2) return(1);
        if (n1 > n2) return(2);
}


