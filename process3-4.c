/*
Second player
Link to semaphores
Link to shm segment

LOOP
  wait(sem2)
    do
  signal(sem1)
*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <semaphore.h>
#include <unistd.h>
#include <time.h>
#include <sys/types.h>
#include <string.h>

#define SHM_KEY 0x1234
#define SIZE 100

#define VSMALLER 0
#define VGREATER 2
#define VEQUAL 1

#define SMALLER "smaller than"
#define GREATER "greater than"
#define EQUAL "equal to"

#define LRAND 0
#define BRAND 100

#define NAME1 "/semaphore1"
#define NAME2 "/semaphore2"

void err_sys(const char* text)
{
    perror(text);
    exit(1);
}

struct shmseg {
	int client;
	int iteration;
	int comparison;
};

int main(int argc, char *argv[])
{
    sem_t*  psem1;  //semaphore that control act3-3
    sem_t*  psem2; //semaphore that control act3-4
    int     sem_value;
    int     result;
    int shmid;
    int Zs;
    int Z1; //low range interval
    int Z2; //high range interval
    int Zc; //number generated by client (middle of interval)
    char message[3][20];
    struct shmseg *shmp;
    int i, j;
    int last = 0; // to avoid generate always the same number



    strcpy(message[0], SMALLER);
    strcpy(message[1], EQUAL);
    strcpy(message[2], GREATER);

    Z1 = LRAND;
    Z2 = BRAND;


    shmid = shmget(SHM_KEY, sizeof(struct shmseg), 0666);
    if (shmid == -1) err_sys("Shared Memory Error");

    //attach to the shmp pointer
    shmp = shmat(shmid, NULL, 0);
    if (shmp == (void*)(-1)) err_sys("Shared Memory attachment error");

    /* Link psem1 */
    psem1 = (sem_t*)sem_open(NAME1, 0, 0600, 0);
    if (psem1 == SEM_FAILED) {
        err_sys("Open psem1");
    }
    /* Read and print psem1 */
    result = sem_getvalue(psem1, &sem_value);
    if (result < 0) {
        err_sys("Read psem1");
    }
    printf("SEM1: %d\n", sem_value);

    /* Link psem2 */
    psem2 = (sem_t*)sem_open(NAME2, 0, 0600, 0);
    if (psem2 == SEM_FAILED) {
        err_sys("Open psem2");
    }

    /* Read and print psem2 */
    result = sem_getvalue(psem2, &sem_value);
    if (result < 0) {
        err_sys("Read psem2");
    }
    printf("SEM2: %d\n", sem_value);

    srand(time(NULL)+getpid());

   while (1)
   {
	if (sem_wait(psem2)<0) err_sys("WAIT psem2");
	//just in the critical zone
       //generate random number 
        Zc = Z1+ (Z2-Z1) / 2;
        if (Zc == last) Zc++;
        last=Zc;
        shmp->client = Zc;
	//exiting critical zone
	if (sem_post(psem1)<0) err_sys("SIGNAL psem1");
	if (sem_wait(psem2)<0) err_sys("WAIT psem2");
// wait for result
       //check result
        if (shmp->comparison == VEQUAL) break;
        if (shmp->comparison == VSMALLER) Z1=Zc;
        if (shmp->comparison == VGREATER) Z2=Zc;
	if (sem_post(psem2)<0) err_sys("SIGNAL psem2");
   }

    printf("The server number is %d\n", Zc);
    printf("The number of iterations has been %d\n", shmp->iteration);

    /* Close psem1 */
    result = sem_close(psem1);
    if (result != 0) {
        err_sys("Close psem1");
    }

    /* Close psem2 */
    result = sem_close(psem2);
    if (result != 0) {
        err_sys("Close psem2");
    }

    //dettach the shmp pointer
    result = shmdt(shmp);
    if (result == (-1)) err_sys("Shared Memory dettachment error");

}
